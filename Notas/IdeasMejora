CHC:
  - Selección Elitista: Selecciona los N mejores cromosomas entre padres e hijos. Los N mejores elementos encontrados hasta el momento permanecerán en la población actual.
  - Cruce Uniforme (HUX): Intercambia exactamente la mitad de los alelos que son distintos en los padres. Garantiza que los hijos tengan una distancia Hamming máxima a sus dos padres. -> Hecho
  - Prevención de Incesto: Se forman N/2 parejas con los elementos de la población. Solo se cruzan las parejas cuyos miembros difieren en un número determinado de bits.
 El umbral se inicializa a H=L/4 (L es la longitud del cromosoma). Si durante un ciclo no se crean descendientes mejores que los de la población anterior, al umbral de cruce se le resta 1.
  - Reinicialización: Cuando el umbral de cruce es menor que cero, la población se reinicia:
    a) Usando el mejor elemento como plantilla (35% de variación aleatoria) e incluyendo una copia suya
    b) Manteniendo el mejor o parte de los mejores de la población y el resto se generan aleatoriamente

Podríamos aumentar el número de parejas (en vez de 1, que sean 2) siguiendo la indicación de Prevención de Incesto, aunque esto podría suponer algunas pérdidas en ejecuciones. 
Podríamos aplicar la Reinicialización b) cuando reiniciamos los elementos a tener en cuenta.


Para aumentar la diversidad podríamos fomentar el uso de elementos que no se encuentren entre los más usado por los mejores ni peores de forma greedy. Pero entonces no nos podríamos olvidar de los mejores y los peores que tenemos entre etapas. Se podría considerar que solo intentaremos interactuar con dichos elementos de la forma normal (greedy). Se intentarían eliminar los peores y, en vez de introducir los mejores, introducimos los meh. 

Se podría utilizar GRASP en vez de Greedy. Es decir, en vez de elegir el elemento con mayor valor/peso, se genera una lista con los x mejores elementos y se elige uno aleatorio de ahí.

Se podría seguir la idea del algoritmo del enfriamiento del metal y en las últimas 50 iteraciones, en vez de seguir la forma de un genético, se podría realizar alguna especie de búsqueda local sobre la mejor solucion.

Si en cierto número de iteraciones no se logra introducir ningún hijo en la población, podríamos reiniciar la población, manteniendo los mejores, con el fin de evitar estancamientos. El problema de reiniciarlo de esta forma, es que puede darse el caso en que se tenga que reiniciar muchas veces y perdamos el tiempo.

Se podría considerar que en vez de utilizar soluciones aleatorias, se usase soluciones obtenidas por GRASP.


12/03/23
En el operador de reparación cambiar la adición/eliminación Greedy por GRASP. Así eliminamos que siempre se elijan los mismos elementos, aumentando la exploración, pero manteniendo el ser competente.
Esto está propuesto en (Genetic and Memetic Algorithm with Diversity Equilibrium based on Greedy Diversification, pg 6).
A esto se le llama operador de diversificación

Se podría generar 1 o 2 soluciones aleatorias por iteración para hacerlas competir con el resto. En [The Shifting Balance Genetic Algorithm: Improving the GA in a Dynamic Environment] se divide la población en un core y unas colonias, y a medida que pasa el tiempo las colonias migran hacia el core y una subpoblación del core migra hacia las colonias para representar las distintas condiciones el entorno. 
En tanto que nuestro tamaño de población es bastante pequeño, en vez de separar la población, podríamos generar una par de soluciones nuevas para simularlo.

GRASP:
int GRASP(int sol[], bool minimizar){
  vector<int> aux;
  vector<int> indices;
  vector<int> valores;
  
  if(minimizar){ //Encontrar peores elementos
    for(int i = 0; i < getSize(); ++i){
      if(sol[i] == 1){
        
      }
    }
  }
  else{ //Encontrar mejores elementos a añadir
    for(int i = 0; i < getSize(); ++i){
      if(sol[i] == 0){
      
      }
    }
  }
  
  Random::shuffle(aux);
  return aux[0];
}
