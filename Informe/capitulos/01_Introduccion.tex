\chapter{Introducción}

%<párrafo indicando lo útil que son las metaheurísticas, tanto para problemas continuos como combinatorios>
Cuando se debe afrontar un problema, la variedad de aproximaciones a seguir resulta ser muy amplia y su elección depende en gran medida de dos factores fundamentales: qué clase de solución se desea extraer del problema, y de qué recursos se dispone para ello. 
Por ello, la rama más clásica de la computación siempre ha tratado de resolver los problemas presentados de forma exacta. 
Es decir, ha tratado cada problema como si solo existiera una sola solución al mismo, la óptima. 
Esta forma de pensamiento se basa en la confianza que se tiene en que los problemas que tradicionalmente eran irresolubles para los humanos, serían más accesibles para los computadores, gracias a su capacidad superior de cómputo pesado.

Esto último resulta cierto en muchos escenarios, fundamentalmente en lo referente a los problemas más puramente matemáticos: operaciones que un humano podría tardar años en resolver a mano, un ordenador podría resolverlas en cuestión de minutos. 
Sin embargo, la mayoría de problemas que nos encontramos en el mundo real son complejos y difíciles de resolver, lo que implica que no se pueda dar con la solución óptima en un tiempo razonable. 

Uno de los problemas más conocidos capaz de ilustrar este hecho es el \textbf{Problema del Viajante de Comercio}. 
Este problema consiste en que, dado un conjunto de ciudades por las que el comercial debe pasar, se debe encontrar el orden en que visita las ciudades de forma que el comercial recorra la menor distancia posible. 
Aunque sea un problema sencillo de formular, la cantidad de posibles caminos incrementa de forma exponencial a la vez que el número de ciudades que se debe recorrer aumenta. 
A medida que el tamaño del problema aumenta nos encontramos aún más complicaciones, toda técnica conocida para extraer la solución exacta requeriría de un tiempo de ejecución que deja de ser asequible incluso para los ordenadores. 
Es decir, tenemos métodos que nos llevan a la solución, pero no existen formas de ejecutarlos. 
Llegados a este punto, si bien tenemos que dejar de plantearnos la pregunta ``¿cuál es el camino más corto?'', podemos empezar a formular una pregunta similar: ``¿qué camino es lo suficientemente corto?''; o sea, a veces tenemos que abandonar la idea de obtener la solución óptima y conformarnos con una solución aproximada de una calidad similar a la óptima.

Por ello, tenemos que encontrar alternativas más viables para la resolución de los problemas, es decir, tenemos que usar algoritmos aproximados, que proporcionan buenas soluciones (no necesariamente la óptima) en un tiempo razonable. 
Los algoritmos aproximados se pueden dividir en heurísticas y metaheurísticas, estas últimas son en las que vamos a estar más interesados. 
Las metaheurísticas suelen ser procedimientos iterativos que guían una heurística subordinada de búsqueda, combinando de forma inteligente distintos conceptos para explorar y explotar adecuadamente el espacio de búsqueda.
Así, las metaheurísticas son una familia de algoritmos aproximados más generales que las heurísticas (que son dependientes del problema a tratar) y aplicables a una gran variedad de problemas de optimización, tanto continuos como combinatorios. 

%<Existen problemas expensives, lo que es y algún ejemplo, y en continuo ya existe algoritmos específicos>
Los problemas de optimización costosa (EOP) o problemas \textit{expensives} se refieren a los problemas que requieren costes elevados, o incluso inasequibles, con el fin de evaluar los candidatos a soluciones. 
Este tipo de problemas existen en una gran cantidad, y cada vez con más frecuencia, de aplicaciones significativas del mundo real. 
%Un ejemplo de problemas \textit{expensives} puede ser el conocido problema del viajante de comercio (TSP).
Por ejemplo, el programa basado en \textit{deep learning} \textbf{AlphaFold2} para predecir estructuras proteicas se considera a nivel mundial como un potencial enfoque a un gran reto en la biología; sin embargo, su entrenamiento requiere 128 TPUv3 \textit{cores} (teniendo estos mayores capacidades computativas que muchos supercomputadores) junto con varias semanas. 
Por esto último, AlphaFold2 se considera computacionalmente muy costoso y no es asequible para muchos investigadores.

También, cabe destacar que ``coste elevado'' es más un concepto relativo que uno absoluto en la mayoría de problemas del mundo real. 
Por ejemplo, en situaciones de emergencia como epidemias o desastres naturales, transporte y envío de materiales para operaciones diarias importantes para salvar vidas, etc., el coste de optimización en situaciones normales se convierte en un coste demasiado elevado. 
Para el caso de los problemas de parámetros reales nos encontramos con que se están planteando cada vez más algoritmos especialmente diseñados para problemas \textit{expensives} (por ejemplo, que la función de evaluación dependa de una simulación).

%<El problema también se da en combinatorio, por nuevos problemas.>
Ahora bien, cada vez es más común usar problemas combinatorios en problemas complejos, lo que implica un mayor coste de evaluación. 
Un ejemplo de esto podría ser el uso de este tipo de algoritmos para optimizar redes neuronales. 
Si bien hemos comentado que en el caso de parámetros reales se han propuesto algoritmos específicos, esto no ha sido el caso para el ámbito de los problemas combinatorios. 
Por lo que es de gran interés crear un algoritmo que resulte útil para este tipo de situaciones, con el fin de reducir los costes todo lo posible. 

%<En este trabajo vamos a ...>
En este Trabajo de Fin de Grado vamos a diseñar, implementar y proponer un algoritmo especialmente diseñado para problemas combinatorios \textit{expensives}. 
El objetivo principal de este algoritmo será encontrar buenas soluciones en una cantidad de tiempo bastante reducida, lo que vamos a traducir en un menor número de evaluaciones; para ello, compararemos los resultados obtenidos del algoritmo propuesto con los resultados pertenecientes a otros tipos de algoritmos conocidos pero no especializados en este tipo de problemas.