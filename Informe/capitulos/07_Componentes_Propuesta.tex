\chapter{Componentes de la propuesta}

En este capítulo se presentan los distintos componentes que se han ido desarrollando como modificaciones de los distintos componentes de los algoritmos de referencia. 
Es importante mencionar que en este capítulo no solo se harán mención de aquellas modificaciones que han resultado fructuosas, si no también aquellas que no han mejorado los resultados de versiones anteriores. 
Estas últimas se conformarán su propia sección aparte al final del capítulo. 
Se describirán detalladamente además de usar pseudocódigo para representarlos.

Téngase en cuenta que solo se explicará brevemente el por qué de estas modificaciones, ya que entraremos en este tema en más profundidad en el siguiente capítulo. 

\section{Histórico}

Al tener tan pocas evaluaciones y con un tamaño tan pequeño de la población no podemos permitirnos una exploración del vecindario de las distintas soluciones en direcciones que en el momento se podrían considerar erróneas, es decir, que ocasionarían que empeorasen las soluciones. 
Por ello, se plantea un sistema capaz de ``recordar'' buenos elementos y malos elementos de la solución; considerándose ``buenos elementos'' aquellos que aparecen en gran medida en las mejores soluciones y no se encuentran en las peores, y ``malos elementos'' aquellos que aparecen en gran medida en las peores soluciones y no se encuentran en las mejores. 
A esto lo llamaremos \textbf{histórico}. 

De esta forma, podemos guiar la exploración de vecindario hacia aquellos elementos que han demostrado ser ``buenos'' y alejarlos de aquellos que han demostrado ser ``malos''. 
Esta lógica la podemos aplicar en el Operador de Reparación y/o en la Mutación. 
Esto se haría sustituyendo la lógica Greedy de tener en cuenta el ratio $valor\_acumulado/peso$ a la hora de añadir o eliminar elementos por un fomento del uso de los datos del histórico: se intentarán añadir de forma aleatoria entre los mejores elementos y se intentarán eliminar de forma aleatoria entre los peores elementos. 

Sin embargo, no podemos permitir que esto guíe toda la ejecución, tenemos que decidir un par de cosas:
\begin{itemize}
	\item ¿Cuándo se para de recopilar datos para generar el histórico? 
	Si recopilamos información de pocas iteraciones puede ocasionar que los datos obtenidos no sean representativos, ya que es posible que no se hayan alcanzado en el momento suficientes soluciones buenas. 
	Si recopilamos información de demasiadas iteraciones puede suponer que los datos obtenidos no sean representativos, ya que la población hubiese podido converger por lo que no hay ningún elemento que se pudiese considerar ``bueno'' o ``malo''; además de que si se dejan pocas ejecuciones para el uso del histórico no se va a poder alcanzar mucha mejora. 
	\item ¿Durante cuántas ejecuciones deberíamos utilizar el histórico? 
	En otras palabras, ¿una vez obtenido los datos del histórico deberíamos utilizarlos hasta el final del algoritmo? 
	La respuesta a esto es: no se debería. 
	Esto es porque no podemos esperar que los datos obtenidos mediante el histórico sean del todo fiables, es decir, podrían estar guiando la solución hasta un máximo local, por lo que las soluciones de la población convergerían rápidamente. 
\end{itemize}

Por lo tanto, llegamos a la conclusión de que no podemos utilizar únicamente el histórico. 
Por ello, lo que haremos será intercalar varias etapas de recopilación de datos y uso del histórico generado. 
Durante la recopilación de datos se procederá de la misma forma que lo haría si esta modificación no estuviese añadida, con la excepción de que se irá guardando en un archivo las distintas soluciones que estamos alcanzando para luego hacer el estudio de sus elementos. 
De las 450 iteraciones totales iremos alternando fases cada 50 iteraciones, de esta forma combinamos en una proporción 4-5 uso del histórico y comportamiento usual. 
Este esquema se ve representado de forma genérica, por simplicidad, en Algoritmo \ref{alg:Historico_Estructura}.

\begin{algorithm}
\caption{Estructura General del Histórico}\label{alg:Historico_Estructura}
\begin{algorithmic}[1]
\Procedure \texttt{Histórico}
\State \texttt{RecDatos} = \texttt{True}
\For{\texttt{i = 0; i < NEVALUACIONES; ++i}}
	\If{\texttt{i}\%50==0 \&\& \texttt{i}$\neq$ 0} /* Puntos de cambio */
		\If{i\%100} /* Empezamos a recopilar datos */
			\State \texttt{RecDatos = True}
			\State Eliminar todos los datos actuales del histograma
			\State Recopilar las soluciones de la población actual
		\Else
			\State \texttt{RecDatos = False}
		\EndIf
	\EndIf
	\If{\texttt{RecDatos}}
		\State Ejecutar los componentes de la manera original
		\State Recopilar las nuevas soluciones
	\Else 
		\State Ejecutar los componentes usando los datos del histórico
	\EndIf
\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

Las modificaciones realizadas al Operador de Reparación y a la Mutación se verán representadas respectivamente en Algoritmo \ref{alg:Historico_OR} y Algoritmo \ref{alg:Historico_Mutacion}.

\begin{algorithm}
\caption{Histórico en Operador de Reparación}\label{alg:Historico_OR}
\begin{algorithmic}[1]
\Procedure \texttt{Historico\_OR}($hijo$)
\State Calcular el peso total de \texttt{hijo} $\xrightarrow{}{}$ \texttt{pesoHijo}
\If{\texttt{pesoHijo > c}}
	\State Eliminar de forma aleatoria los peores elementos según el histórico hasta que \texttt{pesoHijo} deje de sobrepasar \texttt{c}
	\State Si no es posible lo anterior y sigue dándose la condición, eliminar de forma aleatoria los elementos que no aparecen en el histórico hasta que \texttt{pesoHijo} deje de sobrepasar \texttt{c}
	\State Si no es posible lo anterior y sigue dándose la condición, eliminar de forma aleatoria los mejores elementos según el histórico hasta que \texttt{pesoHijo} deje de sobrepasar \texttt{c}
\Else
	\State Añadir de forma aleatoria los mejores elementos según el histórico sin que \texttt{pesoHijo} sobrepase \texttt{c}
	\State Añadir de forma aleatoria los elementos que no aparecen en el histórico sin que \texttt{pesoHijo} sobrepase \texttt{c}
	\State Añadir de forma aleatoria los peores	elementos según el histórico sin que \texttt{pesoHijo} sobrepase \texttt{c}
\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Histórico en Mutación}\label{alg:Historico_Mutacion}
\begin{algorithmic}[1]
\Procedure \texttt{Historico\_Mutacion}($solucion$)
\State \texttt{sustituido = False}
\If{\texttt{!sustituido}}  /*Establecer una lista de prioridades sobre qué mutar y con qué tipo de elementos (una vez que se haya sustituido, se establece \texttt{sustituido = True} y no entra en el resto de elementos de la lista)*/
	\State Sustituir peor 1 por mejor 0
	\State Sustituir 1 sin información por mejor 0
	\State Sustituir peor 1 por 0 sin información
	\State Sustituir 1 sin información por 0 sin información
	\State Sustituir mejor 1 por mejor 0
	\State Sustituir peor 1 por peor 0
	\State Sustituir mejor 1 por 0 sin información 
	\State Sustituir 1 sin información por peor 0
	\State Sustituir mejor 1 por peor 0
\EndIf
\State Aplicar Operador de Reparación con Histórico para rellenar más las soluciones
\EndProcedure
\end{algorithmic}
\end{algorithm}

\section{GRASP}

En el capítulo 6 se ha explicado por qué seguimos un enfoque \textit{Greedy} en el Operador de Reparación. 
Sin embargo esto tiene un problema, y esto es que es bastante probable que siempre se estén eligiendo los mismos pocos elementos cada vez que se usa este componente. 
Si realmente ocurre eso, ocasionaría que la población converja y la evolución se estanque; por ello, debemos encargarnos de encontrar otra alternativa con la que podamos aumentar la diversidad de la población. 

Sin embargo, la diversidad en la población es un arma de doble filo. 
La diversidad es necesaria para explorar el espacio de soluciones, pero puede causar que no finalice el proceso de exploración. 
Si este es el caso, entonces no se le dedicará suficiente tiempo a la fase de explotación, que es esencial para obtener soluciones de mejor calidad. 
Por lo tanto, utilizaremos un operador capaz de introducir cierta diversidad a la población a la vez que asegura cierta calidad. 
Esto es, utilizaremos el operador GRASP (\textit{Greedy Randomized Adaptive Search Procedure}). 

El GRASP vendrá presentado en Algoritmo \ref{alg:GRASP}. 
De forma simplificada, GRASP utiliza de base el algoritmo Greedy para obtener cierta cantidad de mejores elementos, eligirá aleatoriamente uno de ellos y lo devolverá. 
Lo que se entiende como ``mejor elemento'' para GRASP es lo mismo que para lo que se propuso durante la justificación del operador Greedy. 
Además, la cantidad de elementos a considerar dependerá del valor aportado por el mejor elemento; en concreto, solo se considerarán los elementos cuyo valor relativo ($valor\_acumulado/peso$) varíe en un 10\% del valor acumulado del mejor elemento, es decir:
\begin{itemize}
	\item Si se necesitan añadir elementos, nos quedaremos con los elementos que tengan un valor relativo mayor que $0.9*valor\_relativo\_mayor$.
	\item Si se necesitan eliminar elementos, nos quedaremos con los elementos que tengan un valor relativo menor que $1.1*valor\_relativo\_menor$.
\end{itemize}

\begin{algorithm}
\caption{Operador GRASP}\label{alg:GRASP}
\begin{algorithmic}[1]
\Procedure \texttt{GTRASP}($solucion, min$)
\If{\texttt{min}}
	\State Almacenar en \texttt{indices} los elementos activados en \texttt{solucion}
\Else
	\State Almacenar en \texttt{indices} los elementos desactivados en \texttt{solucion}
\EndIf
\State Calcular el valor relativo de \texttt{indices} $\xrightarrow{}{}$ \texttt{valores}
\State \texttt{encontrado = false}
\If{\texttt{min}}
	\State Ordenar \texttt{indices} según \texttt{valores} en orden ascendente
	\For{$i\in 1..size(\texttt{indices}) \&\& !\texttt{encontrado}$}
		\If{\texttt{valores}$_i$ > 1.1$\cdot$\texttt{valores}$_0$}
			\State \texttt{encontrado = true}
			\State Eliminar los elementos de \texttt{indices} desde $i$ hasta $size(\texttt{indices})$
		\EndIf
	\EndFor
\Else
	\State Ordenar \texttt{indices} según \texttt{valores} en orden descendente
	\For{$i\in 1..size(\texttt{indices}) \&\& !\texttt{encontrado}$}
		\If{\texttt{valores}$_i$ < 0.9$\cdot$\texttt{valores}$_0$}
			\State \texttt{encontrado = true}
			\State Eliminar los elementos de \texttt{indices} desde $i$ hasta $size(\texttt{indices})$
		\EndIf
	\EndFor
\EndIf
\State Elegir aleatoriamente algún elemento de \texttt{indices}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\section{Cruce Intensivo}

Para aumentar la explotación de buenas soluciones se propone hacer una modificación en el cruce que realizamos. 
En vez de utilizar el cruce uniforme, que hemos establecido que a cada hijo se le asigna la mitad de los genes de cada uno de los padres (aunque sea de forma aleatoria), en este caso se le asignará un mayor porcentaje de genes del mejor de los padres. 

Para ello, lógicamente tendremos que calcular cuál de los padres es la mejor solución (tiene mayor valor). 
En este caso, no nos sirve aleatorizar una sola lista de índices, ya que la separación no va a ser igualitaria. 
Por lo que tendremos que hacer las separaciones de genes para ambos hijos. 
Una vez hecho esto, se procede de igual forma que en los anteriores cruces, es decir, se le asigna a cada hijo los genes de los padres correspondientes y, posteriormente, se le aplica el operado de reparación a ambos hijos. 
Estoy viene representado en Algoritmo \ref{alg:CI}. 

Por conveniencia, vamos a volver a utilizar la notación que implica que \texttt{padre$_1$} tiene un valor más elevado que \texttt{padre$_2$}.

\begin{algorithm}
\caption{Cruce Intensivo}\label{alg:CI}
\begin{algorithmic}[1]
\Procedure \texttt{Cruce Intensivo}($padre_1, padre_2, porcentaje$)
\State Desordenar los índices (\texttt{indices$_1$}, \texttt{indices$_2$}) que indican la posición de cada elemento
\State \texttt{nelem = $n$*porcentaje}
\For{i in 0..$n$}
	\If{\texttt{i < nelem}}
		\State \texttt{hijo$_1$[indice$_1$[i]]} = \texttt{padre$_1$[indice$_1$[i]]}
		\State \texttt{hijo$_2$[indice$_2$[i]]} = \texttt{padre$_1$[indice$_2$[i]]}
	\Else
		\State \texttt{hijo$_1$[indice$_1$[i]]} = \texttt{padre$_2$[indice$_1$[i]]}
		\State \texttt{hijo$_2$[indice$_2$[i]]} = \texttt{padre$_2$[indice$_2$[i]]}
	\EndIf
\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

\section{Operador NAM}

Esta es una alternativa a cómo se eligen los elementos de la población que se van a cruzar. 
La lógica de este operador es parecida a la prevención de incesto que se propone en el algoritmo CHC, pero sin ser tan restrictiva. 
Se necesita que los padres sean distintos para conseguir que los hijos aporten diversidad a la población si llegan a ser introducidos. 
Una optativa a esto es el operador NAM. 

La implementación de este operador viene representado en el Algoritmo \ref{alg:NAM}. 
Lo que se hace en este operador es elegir a una solución utilizando el Torneo Binario propio de los algoritmos genéticos. 
Para la segunda solución, primero, debemos obtener algunas soluciones de la población distintas a la primera obtenida para el cruce. 
Una vez hecho esto, elegimos como el segundo padre a la solución del segundo grupo más diferente al primer padre; esto es, se calculará la distancia de Hamming entre el primer padre y las soluciones del segundo grupo, y se elegirá como segundo padre aquella solución con mayor distancia de Hamming.

\begin{algorithm}
\caption{Operador NAM}\label{alg:NAM}
\begin{algorithmic}[1]
\Procedure \texttt{Operador NAM}
\State Aplicar \texttt{Torneo Binario} para obtener al primer padre $\xrightarrow{}{}$ \texttt{padre$_1$}
\State Elegir aleatoriamente sin repetición un subconjunto de la población distinta a \texttt{padre$_1$} $\xrightarrow{}{}$ \texttt{indices}.
\State Calcular la distancia de Hamming entre \texttt{padre$_1$} y cada elemento de \texttt{indices}
\State Establecer como \texttt{padre$_2$} la solución de \texttt{indices} con la mayor distancia de Hamming a \texttt{padre$_1$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\section{Cambio Operador Reemplazo (por cercanía)}

Otra forma de intentar mantener cierta diversidad en la población es mediante la modificación del Operador de Reemplazo. 
En vez de siempre eliminar las peores soluciones para introducir otras mejores, estableceremos que las peores soluciones se pueden mantener en la población si están aportando diversidad. 

Este operador viene representado en el Algoritmo \ref{alg:ORC}. 
En definitiva, el objetivo de este operador será comprobar si las nuevas soluciones (hijas) son mejores que las soluciones de la población actual más cercanas a ellas. 
Si las soluciones hijas constituyen una mejora, entonces sustituirán a las soluciones más cercanas en la población. 

\begin{algorithm}
\caption{Operador de Reemplazo por Cercanía}\label{alg:ORC}
\begin{algorithmic}[1]
\Procedure \texttt{Reemplazo Cercanía}($padre_1, padre_2$)
\For{i in 0..\texttt{numHijos}}
	\State Calcular distancia de Hamming de \texttt{hijo$_i$} a todos los elementos de la población
	\State Elegir la solución con la menor distancia de Hamming a \texttt{hijo$_i$} $\xrightarrow{}{}$ \texttt{solucion}
	\If{\texttt{valor$_{solucion}$ < valor$_{hijo_i}$}}
		\State Sustituir \texttt{solucion} por \texttt{hijo$_i$}
	\EndIf
\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

\section{Cambio Operador Reemplazo (por cercanía) intensivo}